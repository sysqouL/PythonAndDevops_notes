----------------------------------------------------------------------------------------------------------------------
    - Метод format
    Значения ключей для поименованных подстановочных полей можно задать в ассоциативном массиве:

        values = {"first":"Bill", "last":"Jordan"}
        show = "Won't you come home {first} {last}?".format(**values)
        print(show):
            Won't you come home Bill Jordan

    Можно так же указывать аргументы со спецификациями форматирования - с помощью > и < производится дополнение пробелами
    справа или слева:

        text = "{0:>22} | {0:<22}"
        print(text.format("O","O")
        22 пробела        O | O         22 пробела

    В f-строках спецификация форматирования задаются внутри фигурных скобок после выражения значения и начинаются с :

        count = 43
        f"{count:5d}" - 5 отступов справа

----------------------------------------------------------------------------------------------------------------------
    Аргументы функции - позиционные и ключевые.
    Позиционным аргументам значения присваиваются в соответствии с их порядком - def positioned(first, second)
    Ключевым аргументам значения присваиваются по умолчанию, которые используются если при вызове функции не было передано
    фактических значений. Во время выполнения функции ключевые параметры можно вызвать по имени, их порядок не важен. При
    использовании ключевых параметров все описанные после них параметры так же должны быть ключевыми.
    def keywords(first=1, second=2)
    Все функции возварщают значения при помощи ключевого слово return. Если его нет - функции возварщает None
    Функции так же являются обьектами. Их можно передавать и хранить вструктурах данных. Можно описать две функции, поместить
    их в список, а затем пройти в цикле по этому списку для их вызова.

    Генераторы
    Замораживают состояние до следующего вызова. Используется ключевое слово yield вместо оператора return. При каждом
    вызове генератор возвращает указанное в yield значение, после чего замораживает состояние до следующего вызова.

----------------------------------------------------------------------------------------------------------------------
    Некоторые методы моудля os:
        os.listdir('.')                                     - вывод содержимого каталога
        os.rename('имя1', 'имя2')                           - переименование файла или каталога
        os.chmod('файл', 0o777)                             - изменение прав доступа файла или каталога
        os.mkdir('/tmpholding')                             - создание каталога
        os.makedirs('/Users/name/tmp/scripts/devops')       - рекурсивное создание каталога
        os.remove('имя файла')                              - удаление файла
        os.rmdir('имя каталога')                            - удаление каталога
        os.removedirs('/Users/name/tmp/scripts/devops')     - удаление дерева каталога
        os.stat('имя файла иил каталога')                   - получение статистики файла или каталога

    Взаимодействие с путями при помощи подмодуля os.path:

        import os
        cur_dir = os.getcwd() - получаем текущий рабочий каталог
        os.path.split(cur_dir) - отделяет конечный уровень пути от родительского пути
        os.path.dirname(cur_dir) - возвращает родительский путь
        os.path.basename(cur_dir) - возвращает название конечного каталога

        os.path.dirname удобно использовать для обхода дерева каталогов:
            while os.path.basename(cur_dir):
                cur_dir = os.path.dirname(cur_dir)
                print(cur_dir)

----------------------------------------------------------------------------------------------------------------------
    При импорте модуля Python код выполняется, а не ждет вызывающий модуль.Что бы добавить функциональность выполняемую
    только при вызове из командной строки используется глобальная переменная main. Запускаемые в командной строке модули
    заканчиваются блоком, в котором это проверяется, из него запускается выполнение ориентированного на командную строку
    кода - блок if __name__ == "__main__":

    Если добавить вверху файла сценария #!/usr/bin/env python и сделать файл испольняемым chmod +x файл.py - можно
    запускать сценарий непосредственно в cmd без упоминания python


----------------